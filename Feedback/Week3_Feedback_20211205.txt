Starting code feedback for Junyue, Week3

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 7.71 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: week1, week2, week7, .git, MiniProject, week3, Feedback

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*~ 
*.tmp

**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# Project name / title
My CMEE Coursework Repository

# Brief description
This repository is divided into several weeks, each week includes code, data, sandbox, results, README.md, and .gitignore. There are some data files downloaded from the [TheMulQuaBio repository](https://github.com/mhasoba/TheMulQuaBio) in the data directory. The sandbox directory includes several test files. And the code directory covers some important scripts.

# Languages
The languages mainly consist of Python, R language, and Shell.

# Dependencies
The special packages for each week can be found in weekly README.md.

# Installation
Guidelines for installing the various projects can be found in weekly README.md.

# Project structure and Usage
Each week's directory is organized with code, data, results, sandbox, and several required files. Guidelines for specific files are in each week's README.md.

# Author name and contact
Junyue Zhang jz1621@ic.ac.uk



**********************************************************************

======================================================================
Looking for the weekly directories...

Found 4 weekly directories: week1, week2, week3, week7

The Week3 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK3...

Found the following directories: code, data, sandbox, results

Found the following files: .gitignore

Checking for readme file in weekly directory...

README file missing, 1 pt deducted

Current Points = 99

Results directory is empty - good! 

Found 27 code files: PP_Dists.R, plotLin.R, DataWrangTidy.R, PP_Regress.R, Florida_warming.tex, Girko.R, Ricker.R, R_conditionals.R, Florida_warming.R, GPDD_Data.R, apply2.R, apply1.R, try.R, break.R, DataWrang.R, Vectorize2.R, sample.R, TreeHeight.R, MyBars.R, preallocate.R, next.R, SQLinR.R, basic_io.R, control_flow.R, browse.R, boilerplate.R, Vectorize1.R

Found the following extra files: Florida_warming.pdf
0.5 pt deducted per extra file

Current Points = 98.5

======================================================================
Testing script/code files...

======================================================================
Inspecting script file PP_Dists.R...

File contents are:

**********************************************************************
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv") # import csv data to a data frame
require(tidyverse) # load the tidyverse package
dplyr::glimpse(MyDF) # inspect and explore data
MyDF$Type.of.feeding.interaction <- as.factor(MyDF$Type.of.feeding.interaction) # change the type to factor

n <- length(levels(MyDF$Type.of.feeding.interaction)) # calculate the number of feeding types
pdf("../results/Pred_Subplots.pdf") # save the first sub-plot
par(mfcol=c(n,1)) # initialize multi-paneled plot
i <- 1
while (i <= n){
  plotDF1 <- subset(MyDF, Type.of.feeding.interaction == levels(MyDF$Type.of.feeding.interaction)[i]) # extract the dataset by every feeding type at each iteration
  par(mfg = c(i,1)) # specify which sub-plot to use in proper order
  hist(log10(plotDF1$Predator.mass), xlab = "log10(Predator Mass (g))", ylab = "Count", col = "lightblue", main = paste("Predator Mass by Feeding Interaction Type:", levels(MyDF$Type.of.feeding.interaction)[i])) # plot histogram including labels and title
  i <- i + 1
}
dev.off() # close the graphic window

pdf("../results/Prey_Subplots.pdf") # save the second sub-plot
par(mfcol=c(n,1)) # initialize multi-paneled plot
i <- 1
while (i <= n){
  plotDF2 <- subset(MyDF, Type.of.feeding.interaction == levels(MyDF$Type.of.feeding.interaction)[i]) # extract the dataset by every feeding type at each iteration
  par(mfg = c(i,1)) # specify which sub-plot to use in proper order
  hist(log10(plotDF2$Prey.mass), xlab = "log10(Prey Mass (g))", ylab = "Count", col = "yellow", main = paste("Prey Mass by Feeding Interaction Type:", levels(MyDF$Type.of.feeding.interaction)[i])) # plot histogram including labels and title
  i <- i + 1
}
dev.off() # close the graphic window

pdf("../results/SizeRatio_Subplots.pdf") # save the third sub-plot
par(mfcol=c(n,1)) # initialize multi-paneled plot
i <- 1
while (i <= n){
  plotDF3 <- subset(MyDF, Type.of.feeding.interaction == levels(MyDF$Type.of.feeding.interaction)[i]) # extract the dataset by every feeding type at each iteration
  par(mfg = c(i,1)) # specify which sub-plot to use in proper order
  hist(log10(plotDF3$Prey.mass / plotDF3$Predator.mass), xlab = "Size Ratio of Prey Mass over Predator Mass", ylab = "Count", col = "red", main = paste("Size Ratio by Feeding Interaction Type:", levels(MyDF$Type.of.feeding.interaction)[i])) # plot histogram including labels and title
  i <- i + 1
}
dev.off() # close the graphic window

feedingTypes <- as.list(levels(MyDF$Type.of.feeding.interaction)) # obtain a list of feeding types
Predator_Mean <- c() # initialize a new vector
Predator_Median <- c() # initialize a new vector
Prey_Mean <- c() # initialize a new vector
Prey_Median <- c() # initialize a new vector
SizeRatio_Mean <- c() # initialize a new vector
SizeRatio_Median <- c() # initialize a new vector
Feeding_Type <- c() # initialize a new vector

for (i in feedingTypes){
  TempDF <- subset(MyDF, Type.of.feeding.interaction == i) # extract the dataset by feeding type at each iteration
  Predator_Mean <- append(Predator_Mean, mean(log10(TempDF$Predator.mass))) # append Predator_Mean
  Predator_Median <- append(Predator_Median, median(log10(TempDF$Predator.mass))) # append Predator_Median
  Prey_Mean <- append(Prey_Mean, mean(log10(TempDF$Prey.mass))) # append Prey_Mean
  Prey_Median <- append(Prey_Median, median(log10(TempDF$Prey.mass))) # append Prey_Median
  SizeRatio_Mean <- append(SizeRatio_Mean, mean(log10(TempDF$Prey.mass / TempDF$Predator.mass))) # append SizeRatio_Mean
  SizeRatio_Median <- append(SizeRatio_Median, median(log10(TempDF$Prey.mass / TempDF$Predator.mass))) # append SizeRatio_Median
  Feeding_Type <- append(Feeding_Type, i) # append Feeding_Type
}

NewDF <- data.frame(Feeding_Type, Predator_Mean, Predator_Median, Prey_Mean, Prey_Median, SizeRatio_Mean, SizeRatio_Median) # create a new dataframe to store the calculations
write.csv(NewDF, "../results/PP_Results.csv") # save the csv file
**********************************************************************

Testing PP_Dists.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):
Loading required package: tidyverse
Error: package or namespace load failed for ‘tidyverse’ in library.dynam(lib, package, package.lib):
 shared object ‘Rcpp.so’ not found
Warning message:
S3 methods ‘.DollarNames.C++Object’, ‘.DollarNames.Module’, ‘print.bytes’, ‘format.Rcpp_stack_trace’, ‘str.Rcpp_stack_trace’, ‘print.Rcpp_stack_trace’ were declared in NAMESPACE but not found 
Error in library.dynam(lib, package, package.lib) : 
  shared object ‘Rcpp.so’ not found
Calls: :: ... tryCatch -> tryCatchList -> tryCatchOne -> <Anonymous>
In addition: Warning message:
S3 methods ‘.DollarNames.C++Object’, ‘.DollarNames.Module’, ‘print.bytes’, ‘format.Rcpp_stack_trace’, ‘str.Rcpp_stack_trace’, ‘print.Rcpp_stack_trace’ were declared in NAMESPACE but not found 
Execution halted

======================================================================
Inspecting script file plotLin.R...

File contents are:

**********************************************************************
x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25 * x +
  rnorm(length(x), mean = 0., sd = 2.5)

# and put them in a dataframe
my_data <- data.frame(x = x, y = y)

# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
pdf("../results/MyLinReg.pdf")
p <-  ggplot(my_data, aes(x = x, y = y,
                          colour = abs(my_lm$residual))
) +
  geom_point() +
  scale_colour_gradient(low = "black", high = "red") +
  theme(legend.position = "none") +
  scale_x_continuous(
    expression(alpha^2 * pi / beta * sqrt(Theta)))

# add the regression line
p <- p + geom_abline(
  intercept = my_lm$coefficients[1][1],
  slope = my_lm$coefficients[2][1],
  colour = "red")
# throw some math on the plot
p <- p + geom_text(aes(x = 60, y = 0,
                       label = "sqrt(alpha) * 2* pi"), 
                   parse = TRUE, size = 6, 
                   colour = "blue")

print(p)
dev.off()
**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):
Error in ggplot(my_data, aes(x = x, y = y, colour = abs(my_lm$residual))) : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file DataWrangTidy.R...

File contents are:

**********************************************************************
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################


require(tidyverse) # load the tidyverse package

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")

############# Inspect the dataset ###############
head(MyData)
dim(MyData) # get the size of the matrix
dplyr::glimpse(MyData) # str(MyData)
utils::View(MyData) # fix(MyData) 
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData) # get the size of the matrix again

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,], stringsAsFactors = F) # stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data
rownames(TempData) <- NULL # assign row names to NULL

############# Convert from wide to long format  ###############

MyWrangledData <- tidyr::gather(TempData, Species, Count, -c(Cultivation, Block, Plot, Quadrat))
# convert the data to long format

MyWrangledData <- dplyr::transmute(MyWrangledData, Cultivation = as.factor(Cultivation), Block = as.factor(Block), Plot = as.factor(Plot), Quadrat = as.factor(Quadrat), Species = as.factor(Species), Count = as.integer(Count))
# assign the correct data types to each column


dplyr::glimpse(MyWrangledData)  # str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############

dplyr::glimpse(MyWrangledData) # like str(), but nicer!
dplyr::filter(MyWrangledData, Count>100) # like subset(), but nicer!
dplyr::slice(MyWrangledData, 10:15) # Look at an arbitrary set of data rows 
**********************************************************************

Testing DataWrangTidy.R...

Output (only first 500 characters): 


**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Encountered error (or warning):
Loading required package: tidyverse
Error: package or namespace load failed for ‘tidyverse’ in library.dynam(lib, package, package.lib):
 shared object ‘Rcpp.so’ not found
Warning message:
S3 methods ‘.DollarNames.C++Object’, ‘.DollarNames.Module’, ‘print.bytes’, ‘format.Rcpp_stack_trace’, ‘str.Rcpp_stack_trace’, ‘print.Rcpp_stack_trace’ were declared in NAMESPACE but not found 
Error in library.dynam(lib, package, package.lib) : 
  shared object ‘Rcpp.so’ not found
Calls: :: ... tryCatch -> tryCatchList -> tryCatchOne -> <Anonymous>
In addition: Warning message:
S3 methods ‘.DollarNames.C++Object’, ‘.DollarNames.Module’, ‘print.bytes’, ‘format.Rcpp_stack_trace’, ‘str.Rcpp_stack_trace’, ‘print.Rcpp_stack_trace’ were declared in NAMESPACE but not found 
Execution halted

======================================================================
Inspecting script file PP_Regress.R...

File contents are:

**********************************************************************
require(ggplot2) # load ggplot2 package
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv") # import csv data to a data frame

pdf("../results/PP_Regress_Results.pdf") # save the pdf file
p <- ggplot(MyDF, aes(x = Prey.mass,
                      y = Predator.mass,
                      colour = Predator.lifestage))
# create a graphics object p 
q <- p + scale_x_continuous("Prey Mass in grams", trans = 'log10') + 
  scale_y_continuous("Predator mass in grams", trans = 'log10') +
  geom_point(size=I(1), shape=I(3)) + geom_smooth(method = "lm", fullrange = TRUE) +
  theme_bw() + facet_grid(Type.of.feeding.interaction ~., scales = "free") + theme(legend.position = "bottom", legend.box = "horizontal") + theme(aspect.ratio = 0.5) + guides(color = guide_legend(nrow = 1))
# add layers and other plot elements
print(q)
dev.off() # close the graphic window

feedingTypes <- as.list(levels(MyDF$Type.of.feeding.interaction))
# convert factor to list
PredatorLifestage <- as.list(levels(MyDF$Predator.lifestage))
# convert factor to list again
Regression_Slope <- c()
Regression_Intercept <- c()
Feeding_Type <- c()
Life_Stage <- c()
R_Squared <- c()
F_Statistic_Value <- c()
P_Value <- c()


for (i in feedingTypes){
  TempDF <- subset(MyDF, Type.of.feeding.interaction == i)
  # subset MyDF to TempDF according to every Type.of.feeding.interaction
  PredatorLifestage <- unique(TempDF$Predator.lifestage)
  # under each feeding type, extract the corresponding predator lifestage
  for (j in PredatorLifestage){
    TempDF1 <- subset(TempDF, Predator.lifestage == j)
    # subset TempDF to TempDF1 according to every existing predator lifestage
    modelTemp <- lm(Predator.mass~Prey.mass, data = TempDF1)
    # fit the linear regression model
    SumTemp <- summary(modelTemp)
    # use the summary function
    if (length(SumTemp$fstatistic[1]) == 0){
      SumTemp$fstatistic[1] <- NA
    } # if f-statistic doesn't exist, assign NA to it
    Feeding_Type<- append(Feeding_Type, i) # append feeding type
    Life_Stage <- append(Life_Stage, j) # append life stage
    Regression_Slope <- append(Regression_Slope, SumTemp$coefficients[2]) # append regression slope
    Regression_Intercept <- append(Regression_Intercept, SumTemp$coefficients[1]) # append regression intercept
    R_Squared <- append(R_Squared, SumTemp$r.squared) # append R^2
    F_Statistic_Value <- append(F_Statistic_Value, SumTemp$fstatistic[1]) # append F-statistic value
    P_Value <- append(P_Value, SumTemp$coefficients[8]) # append p-value
    
    }
}

PPDF <- data.frame(Feeding_Type, Life_Stage, Regression_Slope, Regression_Intercept, R_Squared, F_Statistic_Value, P_Value)
# create a dataframe of regression results corresponding to the lines fitted in the figure
write.csv(PPDF, "../results/PP_Regress_Results.csv") # save the dataframe to a csv delimited table

**********************************************************************

Testing PP_Regress.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):
Loading required package: ggplot2
Error: package or namespace load failed for ‘ggplot2’ in library.dynam(lib, package, package.lib):
 shared object ‘Rcpp.so’ not found
Warning message:
S3 methods ‘.DollarNames.C++Object’, ‘.DollarNames.Module’, ‘print.bytes’, ‘format.Rcpp_stack_trace’, ‘str.Rcpp_stack_trace’, ‘print.Rcpp_stack_trace’ were declared in NAMESPACE but not found 
Error in ggplot(MyDF, aes(x = Prey.mass, y = Predator.mass, colour = Predator.lifestage)) : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file Florida_warming.tex...

File contents are:

**********************************************************************
\documentclass[10pt, a4paper]{article}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage[
backend=biber,
style=alphabetic,
sorting=ynt
]{biblatex}
\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }
 \usepackage[acronym]{glossaries}
\usepackage{optidef}
\addbibresource{mybibliography.bib}
\makeglossaries
\newglossaryentry{entryOne}
{
        name=Glossary Entry,
        description={Glossary entries are used to provide definitions for words in your document}
}    


\title{Is Florida getting warmer}

\author{Junyue Zhang}

\date{10-25-2021}

\begin{document}
  \maketitle
  
  \section{Results}
    The correlation coefficient between years and temperatures is calculated as 0.533. And this calculation is repeated 100 times, each time the temperatures are randomly reshuffled and the correlation coefficient is recalculated. The random correlation coefficients are continuously appended in a new vector. Then the fraction of the random correlation coefficient greater than 0.533 is considered as the approximate, asymptotic p-value. 
    Thus, the p-value is calculated as zero.  
   
  \section{Discussion}
    The p-value indicates the probability that the occurrence of an observed difference just by random chance. The lower p-value is related to the greater statistical significance of the observed difference.
    In this case, the p-value is less than 0.01, which means the difference between Florida temperature and years is significant.
    It can be speculated that the temperatures of Florida are increasing with years.  
    Therefore, Florida is considered getting warmer over years.

  \section{Results}
    After applying a distribution of random correlation coefficients between Florida temperature and time, it can be concluded that Florida is getting warmer over years.

\begin{figure}[h]
  \centering
  \includegraphics[scale = 0.3]{../results/Florida_warming.png}
  \caption{Scatter Plot with the Correlation Coefficient}
  \label{figure1}
\end{figure}
Figure \ref{figure1} shows a scatter plot with the correlation coefficient.


\end{document}
**********************************************************************

Testing Florida_warming.tex...

======================================================================
Inspecting script file Girko.R...

File contents are:

**********************************************************************

build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}

N <- 250 # Assign size of the matrix

M <- matrix(rnorm(N * N), N, N) # Build the matrix

eigvals <- eigen(M)$values # Find the eigenvalues

eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe

my_radius <- sqrt(N) # The radius of the circle is sqrt(N)

ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse

names(ellDF) <- c("Real", "Imaginary") # rename the columns

# plot the eigenvalues
pdf(file = "../results/Girko.pdf")
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))
print(p)
dev.off()

**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):
Error in ggplot(eigDF, aes(x = Real, y = Imaginary)) : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file Ricker.R...

File contents are:

**********************************************************************
Ricker <- function(N0 = 1, r = 1, K = 10, generations = 50){
  # Runs a simulation of the Ricker model
  # Returns a vector of length generations
  N <- rep(NA, generations)  # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations){
    N[t] <- N[t-1] * exp(r*(1.0-(N[t-1]/K)))
  }
  return (N)
}

plot(Ricker(generations = 10), type = "l")
**********************************************************************

Testing Ricker.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.11145s

======================================================================
Inspecting script file R_conditionals.R...

File contents are:

**********************************************************************
# Checks if an integer is even
is.even <- function(n = 2){
  if (n %% 2 == 0)
  {
    return(paste(n, 'is even!'))
  } else {
    return(paste(n, 'is odd!'))
  }
}
is.even(6)
is.even(7)

# Checks if a number is a power of 2
is.power2 <- function(n = 2){
  if (log2(n) %% 1 == 0)
  {
    return(paste(n, 'is a power of 2!'))
  } else {
    return(paste(n, 'is not a power of 2!'))
  }
}
is.power2(4)
is.power2(32)
is.power2(43)

# Checks if a number is prime
is.prime <- function(n){
  if (n == 0){
    return(paste(n,'is a zero!'))
  }
  if (n == 1){
    return(paste(n, 'is just a unit!'))
  }
  ints <- 2:(n-1)
  if (all(n%%ints!=0)){
    return(paste(n, 'is a prime!'))
  } else {
    return(paste(n, 'is a composite!'))
  }
}

is.prime(3)
is.prime(7)
is.prime(0)
is.prime(1)
is.prime(44)
is.prime(35)
**********************************************************************

Testing R_conditionals.R...

Output (only first 500 characters): 


**********************************************************************
[1] "6 is even!"
[1] "7 is odd!"
[1] "4 is a power of 2!"
[1] "32 is a power of 2!"
[1] "43 is not a power of 2!"
[1] "3 is a prime!"
[1] "7 is a prime!"
[1] "0 is a zero!"
[1] "1 is just a unit!"
[1] "44 is a composite!"
[1] "35 is a composite!"

**********************************************************************

Code ran without errors

Time consumed = 0.08044s

======================================================================
Inspecting script file Florida_warming.R...

File contents are:

**********************************************************************
rm(list=ls()) # remove global environment
load("../data/KeyWestAnnualMeanTemperature.RData") # load the annual temperature dataset
ls()
cc <- cor(x = ats[,"Year"], y = ats[,"Temp"], use = "everything", method = "pearson")
# compute the appropriate correlation coefficient between years and Temperature
n <- 100
rcc <- c()
for (i in 1:n){
    ats[,"Temp"] <- sample(ats[,"Temp"])
    # repeat this calculation 100 times, each time randomly reshuffling the temperatures
    temp <- cor(x = ats[,"Year"], y = ats[,"Temp"], use = "everything", method = "pearson")
    # recalculate the correlation coefficient and store it in the "temp" variable
    rcc <- append(rcc, temp) # append "temp" variable to rcc
} 

count <- 0

for (j in rcc){
    if(j > cc){ # if any element in rcc is greater than cc, count plus one
        count <- count + 1
    }
} 
p_value <- count / n # calculate the fraction of the random correlation coefficients greater than the observed one


print(paste("The approximate, asymptotic p-value is", p_value)) # print the p-value


require(ggpubr)
# draw a scatter plot with the correlation coefficient
sp <- ggscatter(ats, x = "Year", y = "Temp",
                add = "reg.line",  # add a regressin line to the plot
                add.params = list(color = "blue", fill = "yellow"), # customize the regressin line
                conf.int = TRUE # add the confidence interval
)

sp + stat_cor(method = "pearson") # add the correlation coefficient

**********************************************************************

Testing Florida_warming.R...

Output (only first 500 characters): 


**********************************************************************
[1] "ats"
[1] "The approximate, asymptotic p-value is 0"

**********************************************************************

Encountered error (or warning):
Loading required package: ggpubr
Warning message:
In library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘ggpubr’
Error in ggscatter(ats, x = "Year", y = "Temp", add = "reg.line", add.params = list(color = "blue",  : 
  could not find function "ggscatter"
Execution halted

======================================================================
Inspecting script file GPDD_Data.R...

File contents are:

**********************************************************************
load("../data/GPDDFiltered.RData") # load GPDDFiltered.RData
require(maps) # load maps package

map(database ="world", col="grey", fill=TRUE, bg="white", lwd=0.5, mar=rep(0,4), border=0, ylim=c(-80,80)) # create a world map
for (i in 1:nrow(gpdd)) {
  points(gpdd$long[i], gpdd$lat[i], cex = 1.2, pch = 19, col = "red")
}
# superimpose on the map all the locations from which we have data in the GPDD dataframe




# As we can see from the map, most of the species are located in North America and Europe. The distribution of the species in North America is concentrated. The species are distributed mainly along the west coast, with the rest spreading across the continent. 
# And the distribution in Europe is dispersive. The species are scattered across the continent, with some concentrated in the west and UK. But in particular, there are two noticeable species separately located in Japan and South Africa.
# These two points are conspicuously far away from others, so the positions of these two species can be carefully checked again.
# Besides, the resolution of this figure is low, a lot of points are jammed together, so it's difficult to distinguish the distribution clearly.
**********************************************************************

Testing GPDD_Data.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):
Loading required package: maps
Warning message:
In library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
Error in map(database = "world", col = "grey", fill = TRUE, bg = "white",  : 
  could not find function "map"
Execution halted

======================================================================
Inspecting script file apply2.R...

File contents are:

**********************************************************************
SomeOperation <- function(v){ # (What does this function do?)
  if (sum(v) > 0){ #note that sum(v) is a single (scalar) value
    return (v * 100)
  }  
  return (v)
}

M <- matrix(rnorm(100), 10, 10)
print(apply(M, 1, SomeOperation))
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 


**********************************************************************
            [,1]       [,2]       [,3]       [,4]       [,5]       [,6]
 [1,]  0.7995023  1.4207504  56.922518  157.94040  126.88802  -98.91093
 [2,]  1.7302052  0.3122485  -6.800311 -184.77388 -210.16583 -165.58198
 [3,] -0.7562197  0.4505367   8.493071   67.39675  -92.15295  -14.40801
 [4,]  0.1363525 -0.8115756 -44.142249  -16.73648   69.74041   60.00734
 [5,] -1.2354087  1.0572785  64.265710  -44.29276   78.41054  -95.28852
 [6,] -0.3548168 -1.5887834 155.074909   99.58796  -16.33529  107.200
**********************************************************************

Code ran without errors

Time consumed = 0.07358s

======================================================================
Inspecting script file apply1.R...

File contents are:

**********************************************************************
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)

## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print(RowMeans)

## Now the variance
RowVars <- apply(M, 1, var)
print(RowVars)

## By column
ColMeans <- apply(M, 2, mean)
print(ColMeans)
**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 


**********************************************************************
 [1]  0.39383317 -0.42839510 -0.45166310  0.10667429 -0.07249856  0.32328350
 [7] -0.53760615 -0.30436086 -0.35472433 -0.29388682
 [1] 0.5991337 0.6430542 0.4898610 1.9339159 0.8445982 1.0442268 1.2081709
 [8] 0.4613612 1.1103486 0.7615626
 [1]  0.1477395 -0.5087761 -0.4757698  0.2771914  0.1122020 -0.3258358
 [7] -0.1971289 -0.1795476  0.2430727 -0.7124913

**********************************************************************

Code ran without errors

Time consumed = 0.05771s

======================================================================
Inspecting script file try.R...

File contents are:

**********************************************************************
doit <- function(x){
  temp_x <- sample(x, replace = TRUE)
  if(length(unique(temp_x)) > 30) {#only take mean if sample was sufficient
    print(paste("Mean of this sample was:", as.character(mean(temp_x))))
  } 
  else {
    stop("Couldn't calculate mean: too few unique values!")
  }
}

set.seed(1345) # again, to get the same result for illustration

popn <- rnorm(50)

hist(popn)

#lapply(1:15, function(i) doit(popn))

result <- lapply(1:15, function(i) try(doit(popn), FALSE))
class(result)

result <- vector("list", 15) #Preallocate/Initialize
for(i in 1:15) {
  result[[i]] <- try(doit(popn), FALSE)
}
**********************************************************************

Testing try.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Mean of this sample was: -0.157308908210876"
[1] "Mean of this sample was: -0.161929636555961"
[1] "Mean of this sample was: 0.0566243156959964"
[1] "Mean of this sample was: -0.0587377219016532"
[1] "Mean of this sample was: -0.0728190342970679"
[1] "Mean of this sample was: -0.123500076346669"
[1] "Mean of this sample was: -0.187779907076969"
[1] "Mean of this sample was: -0.11500905586545"
[1] "Mean of this sample was: -0.0464724710960402"
[1] "Mean of this sample was: 0.0693403259553525"
**********************************************************************

Encountered error (or warning):
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!

======================================================================
Inspecting script file break.R...

File contents are:

**********************************************************************
i <- 0 #Initialize i
    while(i < Inf) {
      if (i == 10) {
        break
      } # Break out of the while loop!
    else {
      cat("i equals ", i, "\n")
      i <- i + 1 # Update i
    }
}

**********************************************************************

Testing break.R...

Output (only first 500 characters): 


**********************************************************************
i equals  0 
i equals  1 
i equals  2 
i equals  3 
i equals  4 
i equals  5 
i equals  6 
i equals  7 
i equals  8 
i equals  9 

**********************************************************************

Code ran without errors

Time consumed = 0.08111s

======================================================================
Inspecting script file DataWrang.R...

File contents are:

**********************************************************************
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data
rownames(TempData) <- NULL

############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

?melt #check out the melt function

MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")

MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############
require(tidyverse)
tidyverse_packages(include_self = TRUE) # the include_self = TRUE means list "tidyverse" as well 
MyWrangledData <- tibble::as_tibble(MyWrangledData) 
MyWrangledData
class(MyWrangledData)
dplyr::glimpse(MyWrangledData) #like str(), but nicer!
dplyr::filter(MyWrangledData, Count>100) #like subset(), but nicer!
dplyr::slice(MyWrangledData, 10:15) # Look at an arbitrary set of data rows

**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 


**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Code ran without errors

Time consumed = 10.00642s

======================================================================
Inspecting script file Vectorize2.R...

File contents are:

**********************************************************************
# Runs the stochastic Ricker equation with gaussian fluctuations

rm(list = ls())

stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100)
{

  N <- matrix(NA, numyears, length(p0))  #initialize empty matrix

  N[1, ] <- p0

  for (pop in 1:length(p0)) { #loop through the populations

    for (yr in 2:numyears){ #for each pop, loop through the years

      N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
    
     }
  
  }
 return(N)

}

# Now write another function called stochrickvect that vectorizes the above to
# the extent possible, with improved performance: 

# print("Vectorized Stochastic Ricker takes:")
# print(system.time(res2<-stochrickvect()))



stochrickvect <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2, numyears = 100) # initialize some parameters
{
  
  N <- matrix(NA, numyears, length(p0))  # initialize an empty matrix
  
  N[1, ] <- p0 # assign p0 to the first row of N
  
  for (yr in 2:numyears){ # from the second row to the last row
      
      N[yr, ] <- N[yr-1, ] * exp(r * (1 - N[yr - 1, ] / K) + rnorm(length(p0), 0, sigma)) # each element in the same row is added one fluctuation from the normal distribution
  }
  return(N) # return the matrix N
}


print("Stochastic Ricker takes:")
print(system.time(res1 <- stochrick())) # calculate how much time the function stochrick takes


print("Vectorized Stochastic Ricker takes:")
print(system.time(res2 <- stochrickvect())) # calculate how much time the function stochrickvect takes

**********************************************************************

Testing Vectorize2.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Stochastic Ricker takes:"
   user  system elapsed 
  0.205   0.000   0.206 
[1] "Vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.014   0.000   0.014 

**********************************************************************

Code ran without errors

Time consumed = 0.31299s

======================================================================
Inspecting script file sample.R...

File contents are:

**********************************************************************
######### Functions ##########

## A function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn, n){
  pop_sample <- sample(popn, n, replace = FALSE)
  return(mean(pop_sample))
}

## Calculate means using a for loop without preallocation:
loopy_sample1 <- function(popn, n, num){
  result1 <- vector() #Initialize empty vector of size 1
  for (i in 1:num){
      result1 <- c(result1, myexperiment(popn, n))
  }
  return(result1)
}

## To run "num" iterations of the experiment using a for loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num){
  result2 <- vector(,num) # Preallocate expected size
  for (i in 1:num){
    result2[i] <- myexperiment(popn, n)
  }
  return(result2)
}

## To run "num" iterations of the experiment using a for loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num){
  result3 <- vector("list", num) #Preallocate expected size
  for(i in 1:num){
    result3[[i]] <- myexperiment(popn, n)
  }
  return(result3)
}

## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num){
  result4 <- lapply(1:num, function(i) myexperiment(popn, n))
  return(result4)
}

## To run "num" iterations of the experiment using vectorization with lapply:
sapply_sample <- function(popn, n, num){
  result5 <- sapply(1:num, function(i) myexperiment(popn, n))
  return(result5)
}

set.seed(12345)
popn <- rnorm(10000) # Generate the population
hist(popn)

n <- 100 # sample size for each experiment
num <- 10000 # Number of times to rerun the experiment
print("Using loops without preallocation on a vector took:" )
print(system.time(loopy_sample1(popn, n, num)))

print("Using loops with preallocation on a vector took:" )
print(system.time(loopy_sample2(popn, n, num)))

print("Using loops with preallocation on a list took:" )
print(system.time(loopy_sample3(popn, n, num)))

print("Using the vectorized sapply function (on a list) took:" )
print(system.time(sapply_sample(popn, n, num)))

print("Using the vectorized lapply function (on a list) took:" )
print(system.time(lapply_sample(popn, n, num)))

**********************************************************************

Testing sample.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops without preallocation on a vector took:"
   user  system elapsed 
  0.291   0.000   0.291 
[1] "Using loops with preallocation on a vector took:"
   user  system elapsed 
  0.155   0.011   0.165 
[1] "Using loops with preallocation on a list took:"
   user  system elapsed 
  0.176   0.016   0.192 
[1] "Using the vectorized sapply function (on a list) took:"
   user  system elapsed 
  0.146   0.019   0.165 
[1] "Using the vectorized lapply function (on a list) took:"
   user  syst
**********************************************************************

Code ran without errors

Time consumed = 1.13595s

======================================================================
Inspecting script file TreeHeight.R...

File contents are:

**********************************************************************

# This function calculates heights of trees given distance of each tree 
# from its base and angle to its top, using  the trigonometric formula 
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"

TreeData <- read.csv("../data/trees.csv") # load the trees.csv file

TreeHeight <- function(degrees, distance){
  radians <- degrees * pi / 180 # convert degrees to radians
  height <- distance * tan(radians) # calculate the tree height using the trigonometric formula
  print(paste("Tree height is:", height)) # print tree height
  
  return (height) # return tree height
}

height <- c() # initialize a new vector
TreeLength <- length(TreeData$Species) # obtain the number of species

for (i in 1:TreeLength){
  z <- TreeHeight(TreeData$Angle.degrees[i], TreeData$Distance.m[i]) # call the function TreeHeight and input the corresponding degrees and distances 
  height <- append(height, z) # append the tree height
}

TreeData$Tree.Height.m <- height # add a new column to the original data frame
write.csv(TreeData, "../results/TreeHts.csv") # create a csv output file
**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Tree height is: 27.8021161438536"
[1] "Tree height is: 45.2460250644405"
[1] "Tree height is: 14.6654828109493"
[1] "Tree height is: 14.9341751666304"
[1] "Tree height is: 35.9703591412599"
[1] "Tree height is: 32.4102133664874"
[1] "Tree height is: 17.4582436344144"
[1] "Tree height is: 30.1373803987097"
[1] "Tree height is: 20.3124778877177"
[1] "Tree height is: 24.4316633466933"
[1] "Tree height is: 27.5021323376702"
[1] "Tree height is: 25.1559006982628"
[1] "Tree height is: 29.392479642
**********************************************************************

Code ran without errors

Time consumed = 0.08470s

======================================================================
Inspecting script file MyBars.R...

File contents are:

**********************************************************************
a <- read.table("../data/Results.txt", header = TRUE)
a$ymin <- rep(0, dim(a)[1]) # append a column of zeros
pdf("../results/MyBars.pdf")
# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y1,
  size = (0.5)
),
colour = "#E69F00",
alpha = 1/2, show.legend = FALSE)

# Print the second linerange
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y2,
  size = (0.5)
),
colour = "#56B4E9",
alpha = 1/2, show.legend = FALSE)

# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y3,
  size = (0.5)
),
colour = "#D55E00",
alpha = 1/2, show.legend = FALSE)

# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis",
                            breaks = seq(3, 5, by = 0.05)) + 
  scale_y_continuous("My y axis") + 
  theme_bw() + 
  theme(legend.position = "none") 
print(p)
dev.off()
**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):
Error in ggplot(a) : could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file preallocate.R...

File contents are:

**********************************************************************
NoPreallocFun <- function(x){
  a <- vector() # empty vector
  for (i in 1:x){
    a <- c(a, i)
    print(a)
    print(object.size(a))
  }
}

system.time(NoPreallocFun(10))


PreallocFun <- function(x){
  a <- rep(NA, x) # pre-allocated vector
  for (i in 1:x){
    a[i] <- i
    print(a)
    print(object.size(a))
  }
}

system.time(PreallocFun(10))
**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
48 bytes
[1] 1 2
48 bytes
[1] 1 2 3
56 bytes
[1] 1 2 3 4
56 bytes
[1] 1 2 3 4 5
72 bytes
[1] 1 2 3 4 5 6
72 bytes
[1] 1 2 3 4 5 6 7
72 bytes
[1] 1 2 3 4 5 6 7 8
72 bytes
[1] 1 2 3 4 5 6 7 8 9
88 bytes
 [1]  1  2  3  4  5  6  7  8  9 10
88 bytes
   user  system elapsed 
  0.017   0.004   0.021 
 [1]  1 NA NA NA NA NA NA NA NA NA
88 bytes
 [1]  1  2 NA NA NA NA NA NA NA NA
88 bytes
 [1]  1  2  3 NA NA NA NA NA NA NA
88 bytes
 [1]  1  2  3  4 NA NA NA NA NA NA
88 bytes
 [1]  1  2  3  4  5 NA N
**********************************************************************

Code ran without errors

Time consumed = 0.08894s

======================================================================
Inspecting script file next.R...

File contents are:

**********************************************************************
for (i in 1:10){
  if ((i %% 2) == 0) # check if the number is odd
      next # pass to next iteration of loop
  print(i)
}
**********************************************************************

Testing next.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors

Time consumed = 0.07122s

======================================================================
Inspecting script file SQLinR.R...

File contents are:

**********************************************************************
#install the sqlite package
install.packages('sqldf')

# To load the packages
library(sqldf)

# The command below opens a connection to the database.
#If the database does not yet exist, one is created in the working directory of R.
db <- dbConnect(SQLite(), dbname='Test.sqlite')

# Now let's enter some data to the table
# Using the db connection to our database, the data are entered using SQL queries
# The next command just create the table
dbSendQuery(conn = db,
            "CREATE TABLE Consumer
       (OriginalID TEXT,
        ConKingdom TEXT,
        ConPhylum TEXT,
        ConSpecies TEXT)")

# Once the table is created, we can enter the data.
#INSERT specifies where the data is entered (here the School table).
#VALUES contains the data

 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (1, 'Animalia', 'Arthropoda', 'Chaoborus trivittatus')")
 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (2, 'Animalia', 'Arthropoda', 'Chaoborus americanus')")
 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (3, 'Animalia', 'Chordata', 'Stizostedion vitreum')")


# Once we have our table, we can query the results using:

dbGetQuery(db, "SELECT * FROM Consumer")
dbGetQuery(db, "SELECT * FROM Consumer WHERE ConPhylum='Chordata'")


# Tables can be also imported from csv files.
# As example, let's use the Biotraits dataset.
# The easiest way is to read the csv files into R as data frames.
# Then the data frames are imported into the database.

Resource <- read.csv("../Data/Resource.csv")  # Read csv files into R

# Import data frames into database
 dbWriteTable(conn = db, name = "Resource", value = Resource, row.names = FALSE)

# Check that the data have been correctly imported into the School table.
 dbListTables(db)                 # The tables in the database
 dbListFields(db,"Resource")       # The columns in a table
 dbReadTable(db, "Resource")    # The data in a table

# Before leaving RSQLite, there is a bit of tidying-up to do.
# The connection to the database is closed, and as precaution
# the three data frames are removed from R’s environment.
 dbDisconnect(db)            # Close connection
 rm(list = c("Resource"))   # Remove data frames



**********************************************************************

Testing SQLinR.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):
Installing package into ‘/home/alexander/R/x86_64-pc-linux-gnu-library/3.4’
(as ‘lib’ is unspecified)
also installing the dependencies ‘blob’, ‘RSQLite’

trying URL 'https://cloud.r-project.org/src/contrib/blob_1.2.2.tar.gz'
Content type 'application/x-gzip' length 10194 bytes
==================================================
downloaded 10194 bytes

trying URL 'https://cloud.r-project.org/src/contrib/RSQLite_2.2.8.tar.gz'
Content type 'application/x-gzip' length 3628717 bytes (3.5 MB)
==================================================
downloaded 3.5 MB

trying URL 'https://cloud.r-project.org/src/contrib/sqldf_0.4-11.tar.gz'
Content type 'application/x-gzip' length 63097 bytes (61 KB)
==================================================
downloaded 61 KB

* installing *source* package ‘blob’ ...
** package ‘blob’ successfully unpacked and MD5 sums checked
** R
** preparing package for lazy loading
Warning: S3 methods ‘!.vctrs_vctr’, ‘!=.vctrs_vctr’, ‘$.vctrs_list_of’, ‘$.vctrs_rcrd’, ‘$.vctrs_sclr’, ‘$.vctrs_vctr’, ‘$<-.vctrs_list_of’, ‘$<-.vctrs_rcrd’, ‘$<-.vctrs_sclr’, ‘$<-.vctrs_vctr’, ‘%%.vctrs_vctr’, ‘%/%.vctrs_vctr’, ‘&.vctrs_vctr’, ‘*.vctrs_vctr’, ‘+.vctrs_vctr’, ‘-.vctrs_vctr’, ‘/.vctrs_vctr’, ‘<.vctrs_vctr’, ‘<=.vctrs_vctr’, ‘==.vctrs_vctr’, ‘>.vctrs_vctr’, ‘>=.vctrs_vctr’, ‘[.vctrs_rcrd’, ‘[.vctrs_sclr’, ‘[.vctrs_unspecified’, ‘[.vctrs_vctr’, ‘[<-.vctrs_list_of’, ‘[<-.vctrs_rcrd’, ‘[<-.vctrs_sclr’, ‘[<-.vctrs_vctr’, ‘[[.vctrs_list_of’, ‘[[.vctrs_rcrd’, ‘[[.vctrs_sclr’, ‘[[.vctrs_vctr’, ‘[[<-.vctrs_list_of’, ‘[[<-.vctrs_rcrd’, ‘[[<-.vctrs_sclr’, ‘[[<-.vctrs_vctr’, ‘^.vctrs_vctr’, ‘dim<-.vctrs_sclr’, ‘dim<-.vctrs_vctr’, ‘dimnames<-.vctrs_sclr’, ‘dimnames<-.vctrs_vctr’, ‘is.na<-.vctrs_sclr’, ‘is.na<-.vctrs [... truncated]
Error in library.dynam(lib, package, package.lib) : 
  shared object ‘vctrs.so’ not found
ERROR: lazy loading failed for package ‘blob’
* removing ‘/home/alexander/R/x86_64-pc-linux-gnu-library/3.4/blob’
ERROR: dependency ‘blob’ is not available for package ‘RSQLite’
* removing ‘/home/alexander/R/x86_64-pc-linux-gnu-library/3.4/RSQLite’
ERROR: dependency ‘RSQLite’ is not available for package ‘sqldf’
* removing ‘/home/alexander/R/x86_64-pc-linux-gnu-library/3.4/sqldf’

The downloaded source packages are in
	‘/tmp/RtmpSihGAF/downloaded_packages’
Warning messages:
1: In install.packages("sqldf") :
  installation of package ‘blob’ had non-zero exit status
2: In install.packages("sqldf") :
  installation of package ‘RSQLite’ had non-zero exit status
3: In install.packages("sqldf") :
  installation of package ‘sqldf’ had non-zero exit status
Error in library(sqldf) : there is no package called ‘sqldf’
Execution halted

======================================================================
Inspecting script file basic_io.R...

File contents are:

**********************************************************************
# A simple script to illustrate R input-output.  
# Run line by line and check inputs outputs to understand what is happening  

MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../results/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE) # Append to it

write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # write row names

write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore column names
**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):
Warning message:
In write.table(MyData[1, ], file = "../results/MyData.csv", append = TRUE) :
  appending column names to file

======================================================================
Inspecting script file control_flow.R...

File contents are:

**********************************************************************
a <- TRUE
if (a == TRUE){
    print("a is TRUE")
    } else {
    print("a is FALSE")
    }            

z <- runif(1)
if (z <= 0.5) {print ("Less than a half")}

z <- runif(1)
if (z <= 0.5) {
  print("Less than a half")
}

for (i in 1:10){
    j <- i * i
    print(paste(i, "squared is", j))
}

for(species in c('Heliodoxa rubinoides', 'Boissonneaua jardini', 'Sula nebouxii')){
    print(paste('The species is', species))
}

v1 <- c("a", "bc", "def")
for (i in v1){
  print(i)
}

i <- 0
while(i < 10){
    i <- i+1
    print(i^2)
}




**********************************************************************

Testing control_flow.R...

Output (only first 500 characters): 


**********************************************************************
[1] "a is TRUE"
[1] "1 squared is 1"
[1] "2 squared is 4"
[1] "3 squared is 9"
[1] "4 squared is 16"
[1] "5 squared is 25"
[1] "6 squared is 36"
[1] "7 squared is 49"
[1] "8 squared is 64"
[1] "9 squared is 81"
[1] "10 squared is 100"
[1] "The species is Heliodoxa rubinoides"
[1] "The species is Boissonneaua jardini"
[1] "The species is Sula nebouxii"
[1] "a"
[1] "bc"
[1] "def"
[1] 1
[1] 4
[1] 9
[1] 16
[1] 25
[1] 36
[1] 49
[1] 64
[1] 81
[1] 100

**********************************************************************

Code ran without errors

Time consumed = 0.07773s

======================================================================
Inspecting script file browse.R...

File contents are:

**********************************************************************
Exponential <- function(N0 = 1, r = 1, generations = 10){
  # Runs a simulation of exponential growth
  # Returns a vector of length generations
  
  N <- rep(NA, generations)  # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations){
    N[t] <- N[t-1] * exp(r)
    browser()
  }
  return (N)
}

plot(Exponential(), type = "l", main = "Exponential growth")



**********************************************************************

Testing browse.R...

Output (only first 500 characters): 


**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Code ran without errors

Time consumed = 0.09689s

======================================================================
Inspecting script file boilerplate.R...

File contents are:

**********************************************************************
# A boilerplate R script

MyFunction <- function(Arg1, Arg2){
  
  # Statements involving Arg1, Arg2:
  print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) # print Arg1's type
  print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) # print Arg2's type
  
  return(c(Arg1, Arg2)) # this is optional, but very useful
}

MyFunction(1,2) #test the function
MyFunction("Riki", "Tiki") # A different test

**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors

Time consumed = 0.07272s

======================================================================
Inspecting script file Vectorize1.R...

File contents are:

**********************************************************************
M <- matrix(runif(1000000), 1000, 1000)

SumAllElements <- function(M){
  Dimensions <- dim(M)
  Tot <- 0
  for (i in 1:Dimensions[1]){
    for (j in 1:Dimensions[2]){
      Tot <- Tot + M[i, j]
    }
  }
  return (Tot)
}

print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))

print("Using the in-built vectorized function, the time taken is:") 
print(system.time(sum(M)))
      
**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops, the time taken is:"
   user  system elapsed 
  0.061   0.005   0.065 
[1] "Using the in-built vectorized function, the time taken is:"
   user  system elapsed 
  0.001   0.000   0.001 

**********************************************************************

Code ran without errors

Time consumed = 0.18519s

======================================================================
======================================================================
Finished running scripts

Ran into 11 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 98.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!